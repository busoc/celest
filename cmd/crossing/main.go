package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"sort"
	"strings"

	"github.com/midbel/linewriter"
)

var (
	BuildVersion = "0.2.0"
	BuildTime    = "2020-05-15"
)

const help = `crosspath takes a trajectory file(s) as generated by inspect and output the
latitude and longitude when there are a crossing with the specified area(s).

crosspath accepts options given via the command line but also via configuration
file. When this option is choosen, the file given as argument is considered to
be one valid configuration file. When not used, crosspath considers its arguments
as one to multiple trajectory files.

the main advantage of using a configuration with crosspath is the ability to
specify multiple areas of interest.

the output of crosspath consists of multiple columns:

* label as given via the label option
* entry time
* entry latitude
* entry longitude
* exit time
* exit latitude
* exit longitude
* approximative crossing duration
* approximative crossing distance

notes that the entry time, latitude and longitude are taken from the first position
of the satellite after entering the area. the time, latitude and longitude are
taken from the last point before exiting the area.

options:

  starts  DATE    only take crossing of area occuring after DATE
  ends    DATE    only take crossing of area occuring before DATE
  label   LABEL   an optional label to the area
  margin  MARGIN  size of the area of interest around the center
  lat     LAT     latitude used as the center of the area of interest
  lng     LNG     longitude used as the center of the area of interest
  night           only take crossing of area occuring during an eclipse
  csv             output crossing as comma separated value
  config          use a configuration file to specify the area(s) of interest
  version         print the version of crosspath and exit
  help            print this help message and exit

usages:
$ crosspath [-starts] [-ends] [-margin] [-label] [-lat] [-lng] [-night] [-csv] <trajectory...>
$ crosspath -config <config.toml>
$ crosspath -version
$ crosspath -help
`

func main() {
	flag.Usage = func() {
		fmt.Fprintln(os.Stderr, strings.TrimSpace(help))
		os.Exit(2)
	}
	var (
		comma  = flag.Bool("csv", false, "csv")
		// list   = flag.Bool("list", false, "list")
		lat    = flag.Float64("lat", 0, "latitude")
		lng    = flag.Float64("lng", 0, "longitude")
		mgn    = flag.Float64("margin", 10, "margin")
		night  = flag.Bool("night", false, "night")
		starts = flag.String("starts", "", "start time")
		ends   = flag.String("ends", "", "end time")
		config = flag.Bool("config", false, "use config file")
		label  = flag.String("label", "", "label")
		version = flag.Bool("version", false, "version")
		help    = flag.Bool("help", false, "help")
	)

	flag.Parse()

	if *help {
		flag.Usage()
		return
	}

	if *version {
		fmt.Fprintf(os.Stdout, "crosspath version %s (%s)", BuildVersion, BuildTime)
		return
	}

	var (
		paths []Path
		err   error
	)
	if *config {
		s, err := Configure(flag.Arg(0))
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		*comma = s.Comma

		paths, err = s.Paths()
	} else {
		sq, err := NewSquare(*lat, *lng, *mgn)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		pd, err := NewPeriod(*starts, *ends)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		ec := Eclipse(*night)

		fmt.Fprintln(os.Stderr, pd.String())
		fmt.Fprintln(os.Stderr, sq.String())
		fmt.Fprintln(os.Stderr, ec.String())

		paths, err = ReadPaths(flag.Args(), NewFilter(*label, sq, pd, ec))
	}
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(2)
	}
	printPaths(Line(*comma), paths)
}

func printPaths(ws *linewriter.Writer, paths []Path) error {
	sort.Slice(paths, func(i, j int) bool {
		return paths[i].Less(paths[j])
	})
	for _, p := range paths {
		var (
			delta = p.Delta()
			dist = p.Distance()
		)
		if p.Label != "" {
			ws.AppendString(p.Label, 12, linewriter.AlignLeft)
		}
		for _, p := range []Point{p.First, p.Last} {
			ws.AppendTime(p.When, "2006-01-02T15:04:05.00", linewriter.AlignLeft)
			ws.AppendFloat(p.Lat, 8, 3, linewriter.AlignRight|linewriter.Float)
			ws.AppendFloat(p.Lng, 8, 3, linewriter.AlignRight|linewriter.Float)
		}
		ws.AppendDuration(delta, 8, linewriter.AlignRight|linewriter.Second)
		ws.AppendFloat(dist, 8, 1, linewriter.AlignRight|linewriter.Float)

		if _, err := io.Copy(os.Stdout, ws); err != nil && err != io.EOF {
			return err
		}
	}
	return nil
}

func Line(comma bool) *linewriter.Writer {
	var opts []linewriter.Option
	if comma {
		opts = append(opts, linewriter.AsCSV(true))
	} else {
		opts = []linewriter.Option{
			linewriter.WithPadding([]byte(" ")),
			linewriter.WithSeparator([]byte("|")),
		}
	}
	return linewriter.NewWriter(8192, opts...)
}
